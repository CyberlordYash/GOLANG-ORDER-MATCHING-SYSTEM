package engine

import (
	"container/heap"
	"sync"
)

/* -------- exported types --------------------------------------------------*/

// Engine orchestrates one order-book per symbol.
type Engine struct {
	mu    sync.Mutex
	books map[string]*orderBook
}

// New returns an empty engine.
func New() *Engine {
	return &Engine{
		books: make(map[string]*orderBook),
	}
}

// Process matches an incoming order against the book for its symbol
// and returns the fills generated by that single order.
// The caller is responsible for persisting the order and trades.
func (e *Engine) Process(o *Order) []Fill {
	e.mu.Lock()
	defer e.mu.Unlock()

	ob := e.get(o.Symbol)
	if o.Side == Buy {
		return ob.matchBuy(o)
	}
	return ob.matchSell(o)
}

/* -------- internal helpers ------------------------------------------------*/

func (e *Engine) get(sym string) *orderBook {
	if ob, ok := e.books[sym]; ok {
		return ob
	}
	ob := newOrderBook()
	e.books[sym] = ob
	return ob
}

func (ob *orderBook) matchBuy(buy *Order) (fills []Fill) {
	for buy.Qty > 0 && ob.sells.Len() > 0 {
		bestSell := ob.sells.levels[0]

		// Price check for limit orders
		if buy.IsLimit && bestSell.price > buy.Price {
			break
		}

		for len(bestSell.orders) > 0 && buy.Qty > 0 {
			sell := bestSell.orders[0]
			tradeQty := min(buy.Qty, sell.Qty)

			fills = append(fills, Fill{
				TakerID: buy.ID,
				MakerID: sell.ID,
				Price:   bestSell.price,
				Qty:     tradeQty,
			})

			buy.Qty -= tradeQty
			sell.Qty -= tradeQty
			if sell.Qty == 0 {
				bestSell.orders = bestSell.orders[1:] // FIFO dequeue
			}
		}
		if len(bestSell.orders) == 0 {
			heap.Pop(&ob.sells) // remove empty price level
		}
	}
	if buy.Qty > 0 && buy.IsLimit {
		ob.enqueue(buy) // rest on the book
	}
	return
}

func (ob *orderBook) matchSell(sell *Order) (fills []Fill) {
	for sell.Qty > 0 && ob.buys.Len() > 0 {
		bestBuy := ob.buys.levels[0]

		if sell.IsLimit && bestBuy.price < sell.Price {
			break
		}

		for len(bestBuy.orders) > 0 && sell.Qty > 0 {
			buy := bestBuy.orders[0]
			tradeQty := min(sell.Qty, buy.Qty)

			fills = append(fills, Fill{
				TakerID: sell.ID,
				MakerID: buy.ID,
				Price:   bestBuy.price,
				Qty:     tradeQty,
			})

			sell.Qty -= tradeQty
			buy.Qty -= tradeQty
			if buy.Qty == 0 {
				bestBuy.orders = bestBuy.orders[1:]
			}
		}
		if len(bestBuy.orders) == 0 {
			heap.Pop(&ob.buys)
		}
	}
	if sell.Qty > 0 && sell.IsLimit {
		ob.enqueue(sell)
	}
	return
}

// enqueue places a resting limit order into the correct sideâ€™s heap.
func (ob *orderBook) enqueue(o *Order) {
	var pq *orderPQ
	if o.Side == Buy {
		pq = &ob.buys
	} else {
		pq = &ob.sells
	}

	// Try to append to an existing price level.
	for _, pl := range pq.levels {
		if pl.price == o.Price {
			pl.orders = append(pl.orders, o)
			return
		}
	}

	// Otherwise create a new price level.
	pl := &priceLevel{price: o.Price, orders: []*Order{o}}
	heap.Push(pq, pl)
}

/* -------- tiny util -------------------------------------------------------*/

func min(a, b int64) int64 {
	if a < b {
		return a
	}
	return b
}
